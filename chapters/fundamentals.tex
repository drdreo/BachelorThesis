\chapter{Technische Grundlagen}

\section{Webkomponenten}
Wie der Name -- Webkomponente -- suggeriert, ermöglicht diese Technologie die Webentwicklung in kleinere, wiederverwendbare, modulare Container zu "`komponentisieren"'.  Der klare Vorteil besteht darin, dass diese Komponenten, unabhängig von einem Framework, vollständig mit "`vanilla"' HTML, CSS und Javascript kreiert werden können, und wie in Kap.~\ref{cha:component_usage} erwähnt, Code wartbar machen.

Webkomponenten bestehen aus 4 separaten W3C Standards\footnote{https://www.w3.org/standards/techs/components\#w3c\_all}:
\begin{itemize}
	\item Custom Elements - APIs um neue HTML Elemente zu definieren
	\item HTML Imports - deklarative Methode um HTML Dokumente in andere zu importieren
	\item HTML Templates - <template>-Element, welches Dokumenten eigenen DOM ermöglicht
	\item Shadow DOM - DOM und Styling abkapseln
\end{itemize}
An einer Standardisierung der Webkomponenten wird bereits Seiten der W3C gearbeitet. Mehr dazu findet sich in \cite{w3c-components}. Jedoch um diese derzeitig in allen größeren Browsern zu nutzen gibt es sogenannte Polyfills \cite{polyfill}. Dieses Polyfill ist ein Codestück, welches Technologie zur Verfügung stellt, die der Browser nicht nativ unterstützt.

\subsection{Custom Elements}
Custom Elements gibt den EntwicklerInnen die Fähigkeit, eigene, voll funktionsfähige DOM-Elemente zu erstellen, existierende HTML-Tags zu erweitern und/oder von anderen EntwicklerInnen erstellte Elemente zu nutzen.  

Diese Spezifikation ist Teil eines größeren Projekts, das Internet zu rationalisieren, im Hinblick auf EntwicklerInnen zugänglichen Schnittstellen, wie beispielsweise die Custom Elements Definition. Jedoch gibt es immer noch Limitierungen, welche das komplette Potenzial -- semantisch und funktional -- einschränken, um das Verhalten bestehender HTML-Elemente vollständig, mit selbst erstellten Elementen, zu beschreiben. Mehr dazu findet sich in \cite{custom-elements}.

Exemplarische Definition:
\begin{JsCode}
	class HelloWorld extends HTMLElement {...};
	customElements.define("hello-world", HelloWorld);
\end{JsCode}

\subsection{HTML Imports}
HTML Imports ermöglichen das Inkludieren und Wiederverwenden von HTML Dokumenten in anderen. Dieser Import kann all jenes enthalten, was in diesem HTML Dokument definiert ist (JavaScript, CSS, HTML, ...). 
Diese Möglichkeit, mehrere Technologien in einem Import, quasi eine URL, zu bündeln, ist eine kleine, aber wesentliche. Aktuell wird es von kaum einem Browser, außer Chrome 62,  unterstützt\footnote{https://caniuse.com/\#search=HTML\%20Import}. Mehr über \emph{HTML Imports} in \cite{html-imports}.

Exemplarischer Import:
\begin{JsCode}
	<link rel="import" href="hello-world.html">
\end{JsCode}

\subsection{HTML Templates}
Das Template Element kapselt Bestandteile einer Webseite ab, welche durch Skripte geklont und zur Laufzeit in das Dokument eingefügt werden können. Die Darstellung des Elements ist beim laden und erstmaligen rendern der Seite leer, und wird zur Laufzeit mit JavaScript gerendert. Dieses Element kann als Inhaltsplatzhalter angesehen werden, welcher für spätere Verwendung gespeichert wird. 

Exemplar:
\begin{JsCode}
<template id="template">
	<p>Hello World!</p>
</template>
\end{JsCode}
Das p-Element, wie in diesem Beispiel gezeigt, ist kein Kindelement des Template Elements im DOM. Es ist ein Kind des DocumentFragment, welches vom content IDL Attribut des Templates zurückgegeben wird, wie in \cite{html-templates} erläutert.

\subsection{Shadow DOM}
Der Shadow Dom bietet eine API zur Erstellung eines separaten Baumes, Shadow Tree genannt, welcher an ein Element angehängt werden kann.
Das bringt die Abkapselung von DOM Elementen und CSS mit sich. Beispielsweise kann unorganisierter CSS-Code von einem Bereich in den anderen durchsickern, was wiederum einen Konflikt erzeugen könnte, welcher unbeabsichtigtes Verhalten hervorbringt. 

Shadow DOM löst dieses Problem durch Isolierung der CSS-Bereiche und Abkapselung des DOM. 
Gemeinsam mit der Custom Element API ermöglicht dies das Schreiben von Komponenten mit in sich geschlossenem HTML, CSS und JavaScript.

%Shadow DOM is just normal DOM with two differences: 1) how it's created/used and 2) how it behaves in relation to the rest of the page. Normally, you create DOM nodes and append them as children of another element. With shadow DOM, you create a scoped DOM tree that's attached to the element, but separate from its actual children. This scoped subtree is called a shadow tree. The element it's attached to is its shadow host. Anything you add in the shadows becomes local to the hosting element, including <style>. This is how shadow DOM achieves CSS style scoping.

Um den Shadow DOM eines Elements zu erstellen muss diesem lediglich der Shadow Root angehängt werden.
\begin{JsCode}
	const p = document.createElement('p');
	const shadowRoot = p.attachShadow({mode: 'open'});
\end{JsCode}
\section{Komponentenorientierte JavaScript-Frameworks und -Bibliotheken}
Sogenannte Javascript Frameworks oder Bibliotheken -- der größte Unterschied liegt darin, dass eine Applikation die Bibliothek einbindet und ein Framework die Anwendung an sich -- sind Werkzeuge um den EntwicklerInnen ein Grundgerüst an Funktionalität zur Verfügung zu stellen. Ein wichtiger Aspekt ist dabei auch die Effizienz und Verwertbarkeit von erfahrenen ProgrammiererInnen entworfenen Code \cite{js-frameworks}.
Eine konkrete Beschreibung findet sich in \cite{wiki-framework}: 
\begin{quote}\textit{Ein Framework gibt somit in der Regel die Anwendungsarchitektur vor. Dabei findet eine Umkehrung der Steuerung (Inversion of Control) statt: Der Programmierer registriert konkrete Implementierungen, die dann durch das Framework gesteuert und benutzt werden, statt -- wie bei einer Klassenbibliothek -- lediglich Klassen und Funktionen zu benutzen. Wird das Registrieren der konkreten Klassen nicht fest im Programmcode verankert, sondern „von außen“ konfiguriert, so spricht man auch von Dependency Injection.}
\end{quote}

Im Anschluss befindet sich eine Auflistung von solchen, zu diesem Zeitpunkt populären Javascript Frameworks und Bibliotheken\footnote{http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core}. Diese arbeiten alle zum Großteil mit Komponenten im Frontend.
\begin{itemize}  
	\item Angular
	\item Polymer
	\item REACT
	\item Vue.js
\end{itemize}
Alle aufgelisteten Frameworks und Bibliotheken sind verfügbar unter der MIT-Lizenz und werden im Anschluss genauer behandelt.

\subsection{Angular}
Angular ist ein TypeScript basierendes Framework. Entwickelt und gewartet von Google, beschrieben als "`Superheroic JavaScript MVW Framework"'. Angular (auch "`Angular 2+"', "`Angular 2"' oder "`ng2"') ist der von Grund auf neu geschriebene, größtenteils inkompatibler Nachfolger von AngularJS (auch "`Angular.js"' oder "`AngularJS 1.x"').
AngularJS wurde im Oktober 2010 veröffentlicht und bekommt weiterhin bug-fixes, \etc. Das neue Angular wurde im September 2016 als Version 2 veröffentlicht. Die aktuellste Version ist 4.3.6 (Stand 23. August 2017). Die Versionsnummer 3 wurde übersprungen, da eines der NPM-Pakete von Angular 2 bereits die Version v3.3.0 trug\footnote{http://angularjs.blogspot.co.at/2016/12/ok-let-me-explain-its-going-to-be.html}.

\subsubsection{Angular Komponente}
Das Kernkonzept von Angular ist die Komponente. Eine komplette Angular-Anwendung kann als Baum, bestehend aus solchen Komponenten, modelliert werden.
Die Definition laut der offiziellen Angular-Dokumentation \cite{angular-component}: 
\begin{quote}
	\begin{english}
		\textit{A component controls a patch of screen called a view. You define a component's application logic—what it does to support the view—inside a class. The class interacts with the view through an API of properties and methods.}
	\end{english}
\end{quote}

\begin{JsCode}
	import { Component } from '@angular/core';
	
	@Component({
		selector: 'hello-world',
		template: '<p>Hello, {{text}}!</p>',
	})
	export class HelloComponent {
		text: string;
		constructor() {
			this.text = 'World';
		}
	}
\end{JsCode}
Angewendet wird diese Komponente wie folgt:
\begin{JsCode}[numbers=none]
	<hello-world></hello-world>
\end{JsCode}
Was folgende Ausgabe rendert:
\begin{JsCode}[numbers=none]
	<p>Hello World</p>
\end{JsCode}

\subsection{Polymer }
Polymer (auch "`Polymer-Project"') ist eine Open Source Javascript-Bibliothek zur Erstellung von Webanwendungen mit Webkomponenten. Erstmals erschienen am 29. Mai 2015 und  wird -- ebenso wie Angular -- von Google entwickelt. Der letzte stabile Release war am 18. Oktober 2017 mit der Version 2.2.0.\\

\subsubsection{Polymer Komponente}
Polymer baut auf der Custom-Element Spezifikation auf und fügt dem eine Reihe an Features hinzu wie beispielsweise \cite{polymer-elements}:
\begin{quote}
	\begin{itemize}
		\item Instanzmethoden für allgemeine Aufgaben
		\item Automatisierung für die Handhabung von Eigenschaften und Attributen, z. B. das Festlegen einer Eigenschaft basierend auf dem entsprechenden Attribut.
		\item Erstellen von Shadow DOM Bäumen für Elementinstanzen basierend auf einem <template>.
		\item Ein Datensystem, welches Datenbindung, Observers für Eigenschaftenänderungen und berechnete Eigenschaften unterstützt.
	\end{itemize}
\end{quote}
\begin{JsCode}
	<link rel='import' href='bower_components/polymer/polymer.html'>
	<dom-module id='hello-world'>
	<template>
	<p>Hello {{text}}</p>
	</template>
	<script>
	class HelloWorld extends Polymer.Element {
		static get is() {
			return 'hello-world';
		}
		constructor() {
			super();
			this.text = 'World';
		}
	}
	customElements.define(HelloWorld.is, HelloWorld);
	</script>
	</dom-module>
\end{JsCode}
Angewendet wird diese Komponente wie folgt:
\begin{JsCode}[numbers=none]
	<link rel='import' href='hello-world.html'>
	<hello-world></hello-world>
\end{JsCode}
Was folgende Ausgabe rendert:
\begin{JsCode}[numbers=none]
	<p>Hello World</p>
\end{JsCode}

\subsection{React}
React (auch "`React.js"' oder "`ReactJS"') wird als "`JavaScript Bibliothek zur Entwicklung von User-Interfaces"'\footnote{https://reactjs.org/blog/2013/06/05/why-react.html} bezeichnet. Es wurde erstmals im März 2013 von Facebook veröffentlicht -- zuvor nur firmenintern verwendet -- und wird seither entwickelt und gewartet. Die neuste Version (Stand 26. September 2017) ist 16.0.0.

\subsubsection{React Komponente}
Aus der Sicht von React sind Komponenten ident mit Javascript Funktionen. Sie können beliebig viele Inputs ("`props"' genannt) besitzen und geben React Elemente zurück, die beschreiben, was am Bildschirm ausgegeben werden soll.
Die Definition entsprechend der offiziellen React Dokumentation \cite{react-component}: 
\begin{quote}
	\begin{english}
		\textit{Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.}
	\end{english}
\end{quote}

\begin{JsCode}
	import React, {Component} from "react";
	
	class HelloWorld extends Component {
		text = '';
		constructor(props) {
			super(props);
			this.text = 'World';
		}
		
		render() {
			return <p>Hello {this.text}</p>;
		}
	}
	export default HelloWorld;
\end{JsCode}
Angewendet wird diese Komponente wie folgt:
\begin{JsCode}[numbers=none]
	import Hello from './HelloWorld';
	<Hello/>
\end{JsCode}
Was folgende Ausgabe erzeugt:
\begin{JsCode}[numbers=none]
	<p>Hello World</p>
\end{JsCode}

\subsection{Vue }
Vue (englische Aussprache [/vju/]), auch "`Vue.js"' genannt, beschreibt sich selbst als ein "`progressives Framework zur Entwicklung von User-Interfaces"'\footnote{https://vuejs.org/v2/guide/}. Vue wurde im Februar 2014 vom Ex-Google-Mitarbeiter Evan You veröffentlicht. Ein markantes Merkmal von Vue ist, dass es hauptsächlich von einer einzelnen Person, ohne die Stütze einer großen Firma, erschaffen wurde. Nur ein paar EntwicklerInnen arbeiten für Evan an der Weiterentwicklung des Frameworks. Die aktuellste Version ist 2.5.2 (Stand 13. Oktober 2017).

\subsubsection{Vue Komponente}
Die Definition laut der Vue Dokumentation \cite{vue-component}: 
\begin{quote}
	\begin{english}
		\textit{Components are one of the most powerful features of Vue. They help you extend basic HTML elements to encapsulate reusable code. At a high level, components are custom elements that Vue’s compiler attaches behavior to. In some cases, they may also appear as a native HTML element extended with the special is attribute.}
	\end{english}
\end{quote}

\begin{JsCode}
	// register
	Vue.component('hello-world', {
		template: '<p>Hello {{ text }} </p>',
		data: function () {
			return {text:"World"};
		}
	})
	// root instance
	new Vue({
		el: '#container'
	})
\end{JsCode}
Angewendet wird diese Komponente wie folgt:
\begin{JsCode}[numbers=none]
	<div id="container">
	<hello-world></hello-world>
	</div>
\end{JsCode}
Was folgende Ausgabe erzeugt:
\begin{JsCode}[numbers=none]
	<div id="container">
	<p>Hello World </p>
	</div>
\end{JsCode}

\section{Representational State Transfer  API}
In diesem Abschnitt wird der Begriff der \begin{english}
Representational State Transfer (REST)
\end{english} Architektur, welcher von Roy Thomas Fielding im Jahre 2000 eingeführt wurde, beschrieben \cite{rest}.
Der als REST bezeichnete Architekturansatz beschreibt die grundlegenden Regeln, wie verteilte Systeme miteinander kommunizieren können.
Fielding hat für diese Architektur Restriktionen zusammengefasst, welche in dem folgendem Abschnitt erläutert werden.
\subsection{Restriktionen}
\subsubsection{Null Stil}
Der Null Stil beschreibt den Status eines Systems, wenn jenes keine Abgrenzungen der enthaltenen Komponenten aufweist. Von diesem Status weg wird REST definiert. 
\subsubsection{Client-Server}
Nach dem Client-Server-Architektur Stil werden Aufgabenbereiche auf Client und Server aufgeteilt. Meist wird vom Client eine Aufgabe gestellt, welche vom Server verarbeitet wird. 
\subsubsection{Zustandslosigkeit}
Jegliche REST-Zugriffe sind zustandslos. Heißt, jede Anfrage enthält alle benötigten Informationen, die der Endpunkt braucht, um diese zu verstehen und zu verarbeiten. Unabhängig davon, wer oder was die Anfrage getätigt hat.  
\subsubsection{Einheitliche Schnittstelle}
Eine standardisierte Schnittstelle soll durch die Trennung der Zuständigkeiten die Einfachheit fördern, sowie die darunter liegende Implementierung und Kommunikation verbergen. 
\subsubsection{Caching}
Die effizienteste Netzwerkanfrage ist jene, die das Netzwerk nicht benutzt.
Soll heißen, dass eine wiederverwendbare, gecachte  Antwort die Performanteste ist. 
\subsubsection{Stufen Systeme}
Das Zielsystem soll, wie in Kap.~\ref{cha:webapplication_structure} weiter behandelt, mit n-Stufen aufgebaut sein, damit der Anwender lediglich auf eine Schnittstelle, einer Stufe, zugreifen muss, und die anderen verborgen bleiben können.

\subsection{Praxis}
In der Praxis wird das REST-Paradigma bevorzugt per HTTP/S realisiert. Services werden über eine URL/ einen URI angesprochen. Wie eine Anfrage bearbeitet werden soll, kann per HTTP-Methode (GET, POST, PUT, \etc) verfeinert werden. 
